diff --git a/fs/namespace.c b/fs/namespace.c
index b5dcd0d..1f51dbe 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -27,36 +27,30 @@
 #include <linux/bootmem.h>
 #include <linux/task_work.h>
 #include <linux/sched/task.h>
-#if defined(CONFIG_KSU_SUSFS_SUS_MOUNT) || defined(CONFIG_KSU_SUSFS_TRY_UMOUNT)
+#if defined(CONFIG_KSU_SUSFS_SUS_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT)
 #include <linux/susfs_def.h>
 #endif
 
 #include "pnode.h"
 #include "internal.h"
 
-#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+#if defined(CONFIG_KSU_SUSFS_SUS_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT)
 extern bool susfs_is_current_ksu_domain(void);
-extern bool susfs_is_current_zygote_domain(void);
 extern bool susfs_is_boot_completed_triggered;
+#endif // #if defined(CONFIG_KSU_SUSFS_SUS_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT)
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 static DEFINE_IDA(susfs_ksu_mnt_group_ida);
+static atomic64_t susfs_ksu_mounts = ATOMIC64_INIT(0);
 static int susfs_mnt_group_start = DEFAULT_KSU_MNT_GROUP_ID;
 
 #define CL_COPY_MNT_NS BIT(25) /* used by copy_mnt_ns() */
-#endif
+#endif // #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-extern void susfs_auto_add_sus_ksu_default_mount(const char __user *to_pathname);
-bool susfs_is_auto_add_sus_ksu_default_mount_enabled = true;
-#endif
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
-extern void susfs_auto_add_sus_bind_mount(const char *pathname, struct path *path_target);
-bool susfs_is_auto_add_sus_bind_mount_enabled = true;
-#endif
 #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
 extern void susfs_auto_add_try_umount_for_bind_mount(struct path *path);
 bool susfs_is_auto_add_try_umount_for_bind_mount_enabled = true;
-#endif
+#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
 
 /* Maximum number of mounts in a mount namespace */
 unsigned int sysctl_mount_max __read_mostly = 100000;
@@ -2616,20 +2610,16 @@ static int do_loopback(struct path *path, const char *old_name,
 		umount_tree(mnt, UMOUNT_SYNC);
 		unlock_mount_hash();
 	}
-#if defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT)
-	if (susfs_is_current_ksu_domain()) {
-#if defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT)
-		if (susfs_is_auto_add_sus_bind_mount_enabled) {
-			susfs_auto_add_sus_bind_mount(old_name, &old_path);
-		}
-#endif
-#if defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT)
-		if (susfs_is_auto_add_try_umount_for_bind_mount_enabled) {
-			susfs_auto_add_try_umount_for_bind_mount(path);
-		}
-#endif
+#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
+	// - Check if bind mounted path should be umounted automatically.
+	// - We keep checking for ksu process only until boot-completed stage is triggered
+	if (!susfs_is_boot_completed_triggered &&
+		 susfs_is_current_ksu_domain() &&
+		 susfs_is_auto_add_try_umount_for_bind_mount_enabled)
+	{
+		susfs_auto_add_try_umount_for_bind_mount(path);
 	}
-#endif // #if defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT)
+#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
 
 out2:
 	unlock_mount(mp);
@@ -3230,15 +3220,6 @@ long do_mount(const char *dev_name, const char __user *dir_name,
 	else
 		retval = do_new_mount(&path, type_page, sb_flags, mnt_flags,
 				      dev_name, data_page);
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-	// For both Legacy and Magic Mount KernelSU
-	if (!susfs_is_boot_completed_triggered && !retval && susfs_is_auto_add_sus_ksu_default_mount_enabled &&
-			(!(flags & (MS_REMOUNT | MS_BIND | MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE)))) {
-		if (!susfs_is_boot_completed_triggered && susfs_is_current_ksu_domain()) {
-			susfs_auto_add_sus_ksu_default_mount(dir_name);
-		}
-	}
-#endif
 dput_out:
 	path_put(&path);
 	return retval;
@@ -3928,6 +3909,11 @@ void susfs_reorder_mnt_id(void) {
 		return;
 	}
 
+	// Do not reorder the mnt_id if there is no any ksu mount at all
+	if (atomic64_read(&susfs_ksu_mounts) == 0) {
+		return;
+	}
+
 	get_mnt_ns(mnt_ns);
 	first_mnt_id = list_first_entry(&mnt_ns->list, struct mount, mnt_list)->mnt_id;
 	list_for_each_entry(mnt, &mnt_ns->list, mnt_list) {
@@ -3941,16 +3927,3 @@ void susfs_reorder_mnt_id(void) {
 	put_mnt_ns(mnt_ns);
 }
 #endif
-#ifdef CONFIG_KSU_SUSFS
-bool susfs_is_mnt_devname_ksu(struct path *path) {
-	struct mount *mnt;
-
-	if (path && path->mnt) {
-		mnt = real_mount(path->mnt);
-		if (mnt && mnt->mnt_devname && !strcmp(mnt->mnt_devname, "KSU")) {
-			return true;
-		}
-	}
-	return false;
-}
-#endif
diff --git a/fs/statfs.c b/fs/statfs.c
index 25ff6b5..f13ac70 100644
--- a/fs/statfs.c
+++ b/fs/statfs.c
@@ -240,11 +240,6 @@ int vfs_ustat(dev_t dev, struct kstatfs *sbuf)
 	if (!s)
 		return -EINVAL;
 
-#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-	if (unlikely(s->s_root->d_inode->i_mapping->flags & BIT_SUS_MOUNT)) {
-		return -EINVAL;
-	}
-#endif
 	err = statfs_by_dentry(s->s_root, sbuf);
 	drop_super(s);
 	return err;
diff --git a/fs/susfs.c b/fs/susfs.c
index 543144c..71c1c5a 100644
--- a/fs/susfs.c
+++ b/fs/susfs.c
@@ -17,8 +17,6 @@
 #include <linux/susfs.h>
 #include "mount.h"
 
-static spinlock_t susfs_spin_lock;
-
 extern bool susfs_is_current_ksu_domain(void);
 
 #ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
@@ -40,6 +38,7 @@ bool susfs_starts_with(const char *str, const char *prefix) {
 
 /* sus_path */
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
+static DEFINE_SPINLOCK(susfs_spin_lock_sus_path);
 static LIST_HEAD(LH_SUS_PATH_LOOP);
 static LIST_HEAD(LH_SUS_PATH_ANDROID_DATA);
 static LIST_HEAD(LH_SUS_PATH_SDCARD);
@@ -166,7 +165,7 @@ void susfs_add_sus_path(void __user **user_info) {
 		}
 		list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_ANDROID_DATA, list) {
 			if (unlikely(!strcmp(cursor->info.target_pathname, path.dentry->d_name.name))) {
-				spin_lock(&susfs_spin_lock);
+				spin_lock(&susfs_spin_lock_sus_path);
 				cursor->info.target_ino = info.target_ino;
 				strncpy(cursor->info.target_pathname, path.dentry->d_name.name, SUSFS_MAX_LEN_PATHNAME - 1);
 				strncpy(cursor->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
@@ -174,7 +173,7 @@ void susfs_add_sus_path(void __user **user_info) {
 				cursor->path_len = strlen(cursor->info.target_pathname);
 				SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully updated to LH_SUS_PATH_ANDROID_DATA\n",
 							cursor->info.target_ino, cursor->target_pathname, cursor->info.i_uid);
-				spin_unlock(&susfs_spin_lock);
+				spin_unlock(&susfs_spin_lock_sus_path);
 				info.err = 0;
 				goto out_kfree_tmp_buf;
 			}
@@ -190,11 +189,11 @@ void susfs_add_sus_path(void __user **user_info) {
 		new_list->info.i_uid = info.i_uid;
 		new_list->path_len = strlen(new_list->info.target_pathname);
 		INIT_LIST_HEAD(&new_list->list);
-		spin_lock(&susfs_spin_lock);
+		spin_lock(&susfs_spin_lock_sus_path);
 		list_add_tail(&new_list->list, &LH_SUS_PATH_ANDROID_DATA);
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_ANDROID_DATA\n",
 					new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
-		spin_unlock(&susfs_spin_lock);
+		spin_unlock(&susfs_spin_lock_sus_path);
 		info.err = 0;
 		goto out_kfree_tmp_buf;
 	} else if (strstr(resolved_pathname, sdcard_path.target_pathname)) {
@@ -205,7 +204,7 @@ void susfs_add_sus_path(void __user **user_info) {
 		}
 		list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_SDCARD, list) {
 			if (unlikely(!strcmp(cursor->info.target_pathname, path.dentry->d_name.name))) {
-				spin_lock(&susfs_spin_lock);
+				spin_lock(&susfs_spin_lock_sus_path);
 				cursor->info.target_ino = info.target_ino;
 				strncpy(cursor->info.target_pathname, path.dentry->d_name.name, SUSFS_MAX_LEN_PATHNAME - 1);
 				strncpy(cursor->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
@@ -213,7 +212,7 @@ void susfs_add_sus_path(void __user **user_info) {
 				cursor->path_len = strlen(cursor->info.target_pathname);
 				SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully updated to LH_SUS_PATH_SDCARD\n",
 							cursor->info.target_ino, cursor->target_pathname, cursor->info.i_uid);
-				spin_unlock(&susfs_spin_lock);
+				spin_unlock(&susfs_spin_lock_sus_path);
 				info.err = 0;
 				goto out_kfree_tmp_buf;
 			}
@@ -229,11 +228,11 @@ void susfs_add_sus_path(void __user **user_info) {
 		new_list->info.i_uid = info.i_uid;
 		new_list->path_len = strlen(new_list->info.target_pathname);
 		INIT_LIST_HEAD(&new_list->list);
-		spin_lock(&susfs_spin_lock);
+		spin_lock(&susfs_spin_lock_sus_path);
 		list_add_tail(&new_list->list, &LH_SUS_PATH_SDCARD);
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_SDCARD\n",
 					new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
-		spin_unlock(&susfs_spin_lock);
+		spin_unlock(&susfs_spin_lock_sus_path);
 		info.err = 0;
 		goto out_kfree_tmp_buf;
 	}
@@ -300,7 +299,7 @@ void susfs_add_sus_path_loop(void __user **user_info) {
 
 	list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_LOOP, list) {
 		if (unlikely(!strcmp(cursor->info.target_pathname, resolved_pathname))) {
-			spin_lock(&susfs_spin_lock);
+			spin_lock(&susfs_spin_lock_sus_path);
 			cursor->info.target_ino = info.target_ino;
 			strncpy(cursor->info.target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
 			strncpy(cursor->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
@@ -308,7 +307,7 @@ void susfs_add_sus_path_loop(void __user **user_info) {
 			cursor->path_len = strlen(cursor->info.target_pathname);
 			SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully updated to LH_SUS_PATH_LOOP\n",
 						cursor->info.target_ino, cursor->target_pathname, cursor->info.i_uid);
-			spin_unlock(&susfs_spin_lock);
+			spin_unlock(&susfs_spin_lock_sus_path);
 			goto out_set_sus_path;
 		}
 	}
@@ -323,11 +322,11 @@ void susfs_add_sus_path_loop(void __user **user_info) {
 	new_list->info.i_uid = info.i_uid;
 	new_list->path_len = strlen(new_list->info.target_pathname);
 	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_path);
 	list_add_tail(&new_list->list, &LH_SUS_PATH_LOOP);
 	SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_LOOP\n",
 				new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_path);
 out_set_sus_path:
 	spin_lock(&inode->i_lock);
 	set_bit(AS_FLAGS_SUS_PATH, &inode->i_mapping->flags);
@@ -460,169 +459,8 @@ bool susfs_is_inode_sus_path(struct inode *inode) {
 
 /* sus_mount */
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+static DEFINE_SPINLOCK(susfs_spin_lock_sus_mount);
 bool susfs_hide_sus_mnts_for_all_procs = true; // hide sus mounts for all processes by default
-static LIST_HEAD(LH_SUS_MOUNT);
-static void susfs_update_sus_mount_inode(char *target_pathname) {
-	struct mount *mnt = NULL;
-	struct path p;
-	struct inode *inode = NULL;
-	int err = 0;
-
-	err = kern_path(target_pathname, 0, &p);
-	if (err) {
-		SUSFS_LOGE("Failed opening file '%s'\n", target_pathname);
-		return;
-	}
-
-	/* It is important to check if the mount has a legit peer group id, if so we cannot add them to sus_mount,
-	 * since there are chances that the mount is a legit mountpoint, and it can be misued by other susfs functions in future.
-	 * And by doing this it won't affect the sus_mount check as other susfs functions check by mnt->mnt_id
-	 * instead of BIT_SUS_MOUNT.
-	 */
-	mnt = real_mount(p.mnt);
-	if (mnt->mnt_group_id > 0 && // 0 means no peer group
-		mnt->mnt_group_id < DEFAULT_KSU_MNT_GROUP_ID) {
-		SUSFS_LOGE("skip setting SUS_MOUNT inode state for path '%s' since its source mount has a legit peer group id\n", target_pathname);
-		return;
-	}
-
-	inode = d_inode(p.dentry);
-	if (!inode) {
-		path_put(&p);
-		SUSFS_LOGE("inode is NULL\n");
-		return;
-	}
-
-	if (!(inode->i_mapping->flags & BIT_SUS_MOUNT)) {
-		spin_lock(&inode->i_lock);
-		set_bit(AS_FLAGS_SUS_MOUNT, &inode->i_mapping->flags);
-		spin_unlock(&inode->i_lock);
-	}
-	path_put(&p);
-}
-
-void susfs_add_sus_mount(void __user **user_info) {
-	struct st_susfs_sus_mount info = {0};
-	struct st_susfs_sus_mount_list *cursor = NULL, *temp = NULL;
-	struct st_susfs_sus_mount_list *new_list = NULL;
-
-	if (copy_from_user(&info, (struct st_susfs_sus_mount __user*)*user_info, sizeof(info))) {
-		info.err = -EFAULT;
-		goto out_copy_to_user;
-	}
-
-#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)
-#ifdef CONFIG_MIPS
-	info.target_dev = new_decode_dev(info.target_dev);
-#else
-	info.target_dev = huge_decode_dev(info.target_dev);
-#endif /* CONFIG_MIPS */
-#else
-	info.target_dev = old_decode_dev(info.target_dev);
-#endif /* defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64) */
-
-	list_for_each_entry_safe(cursor, temp, &LH_SUS_MOUNT, list) {
-		if (unlikely(!strcmp(cursor->info.target_pathname, info.target_pathname))) {
-			spin_lock(&susfs_spin_lock);
-			memcpy(&cursor->info, &info, sizeof(info));
-			susfs_update_sus_mount_inode(cursor->info.target_pathname);
-			SUSFS_LOGI("target_pathname: '%s', target_dev: '%lu', is successfully updated to LH_SUS_MOUNT\n",
-						cursor->info.target_pathname, cursor->info.target_dev);
-			spin_unlock(&susfs_spin_lock);
-			goto out_copy_to_user;
-		}
-	}
-
-	new_list = kmalloc(sizeof(struct st_susfs_sus_mount_list), GFP_KERNEL);
-	if (!new_list) {
-		info.err = -ENOMEM;
-		goto out_copy_to_user;
-	}
-
-	memcpy(&new_list->info, &info, sizeof(info));
-	susfs_update_sus_mount_inode(new_list->info.target_pathname);
-
-	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
-	list_add_tail(&new_list->list, &LH_SUS_MOUNT);
-	SUSFS_LOGI("target_pathname: '%s', target_dev: '%lu', is successfully added to LH_SUS_MOUNT\n",
-				new_list->info.target_pathname, new_list->info.target_dev);
-	spin_unlock(&susfs_spin_lock);
-	info.err = 0;
-out_copy_to_user:
-	if (copy_to_user(&((struct st_susfs_sus_mount __user*)*user_info)->err, &info.err, sizeof(info.err))) {
-		info.err = -EINVAL;
-	}
-	SUSFS_LOGI("CMD_SUSFS_ADD_SUS_MOUNT -> ret: %d\n", info.err);
-}
-
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
-void susfs_auto_add_sus_bind_mount(const char *pathname, struct path *path_target) {
-	struct mount *mnt;
-	struct inode *inode;
-
-	mnt = real_mount(path_target->mnt);
-	if (mnt->mnt_group_id > 0 && // 0 means no peer group
-		mnt->mnt_group_id < DEFAULT_KSU_MNT_GROUP_ID) {
-		// return 0 here as we still want it to be added to try_umount list
-		return;
-	}
-	inode = path_target->dentry->d_inode;
-	if (!inode) return;
-	if (!(inode->i_mapping->flags & BIT_SUS_MOUNT)) {
-		spin_lock(&inode->i_lock);
-		set_bit(AS_FLAGS_SUS_MOUNT, &inode->i_mapping->flags);
-		spin_unlock(&inode->i_lock);
-		SUSFS_LOGI("set SUS_MOUNT inode state for source bind mount path '%s'\n", pathname);
-	}
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
-
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-void susfs_auto_add_sus_ksu_default_mount(const char __user *to_pathname) {
-	char *pathname = NULL;
-	struct path path;
-	struct inode *inode;
-
-	pathname = kmalloc(SUSFS_MAX_LEN_PATHNAME, GFP_KERNEL);
-	if (!pathname) {
-		SUSFS_LOGE("no enough memory\n");
-		return;
-	}
-	// Here we need to re-retrieve the struct path as we want the new struct path, not the old one
-	if (strncpy_from_user(pathname, to_pathname, SUSFS_MAX_LEN_PATHNAME-1) < 0) {
-		SUSFS_LOGE("strncpy_from_user()\n");
-		goto out_free_pathname;
-		return;
-	}
-	if ((!strncmp(pathname, "/data/adb/modules", 17) ||
-		 !strncmp(pathname, "/system", 7) ||
-		 !strncmp(pathname, "/system_ext", 11) ||
-		 !strncmp(pathname, "/vendor", 7) ||
-		 !strncmp(pathname, "/product", 8) ||
-		 !strncmp(pathname, "/odm", 4)) &&
-		 !kern_path(pathname, LOOKUP_FOLLOW, &path)) {
-		goto set_inode_sus_mount;
-	}
-	goto out_free_pathname;
-set_inode_sus_mount:
-	inode = path.dentry->d_inode;
-	if (!inode) {
-		goto out_path_put;
-		return;
-	}
-	if (!(inode->i_mapping->flags & BIT_SUS_MOUNT)) {
-		spin_lock(&inode->i_lock);
-		set_bit(AS_FLAGS_SUS_MOUNT, &inode->i_mapping->flags);
-		spin_unlock(&inode->i_lock);
-		SUSFS_LOGI("set SUS_MOUNT inode state for default KSU mount path '%s'\n", pathname);
-	}
-out_path_put:
-	path_put(&path);
-out_free_pathname:
-	kfree(pathname);
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
 
 void susfs_set_hide_sus_mnts_for_all_procs(void __user **user_info) {
 	struct st_susfs_hide_sus_mnts_for_all_procs info = {0};
@@ -631,9 +469,9 @@ void susfs_set_hide_sus_mnts_for_all_procs(void __user **user_info) {
 		info.err = -EFAULT;
 		goto out_copy_to_user;
 	}
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_mount);
 	susfs_hide_sus_mnts_for_all_procs = info.enabled;
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_mount);
 	SUSFS_LOGI("susfs_hide_sus_mnts_for_all_procs: %d\n", info.enabled);
 	info.err = 0;
 out_copy_to_user:
@@ -651,9 +489,9 @@ void susfs_set_umount_for_zygote_iso_service(void __user **user_info) {
 		info.err = -EFAULT;
 		goto out_copy_to_user;
 	}
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_mount);
 	susfs_is_umount_for_zygote_iso_service_enabled = info.enabled;
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_mount);
 	SUSFS_LOGI("susfs_is_umount_for_zygote_iso_service_enabled: %d\n", info.enabled);
 	info.err = 0;
 out_copy_to_user:
@@ -666,6 +504,7 @@ out_copy_to_user:
 
 /* sus_kstat */
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+static DEFINE_SPINLOCK(susfs_spin_lock_sus_kstat);
 static DEFINE_HASHTABLE(SUS_KSTAT_HLIST, 10);
 static int susfs_update_sus_kstat_inode(char *target_pathname) {
 	struct path p;
@@ -711,7 +550,7 @@ void susfs_add_sus_kstat(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_kstat);
 	hash_for_each_safe(SUS_KSTAT_HLIST, bkt, tmp_node, tmp_entry, node) {
 		if (!strcmp(tmp_entry->info.target_pathname, info.target_pathname)) {
 			hash_del(&tmp_entry->node);
@@ -720,7 +559,7 @@ void susfs_add_sus_kstat(void __user **user_info) {
 			break;
 		}
 	}
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_kstat);
 
 	new_entry = kmalloc(sizeof(struct st_susfs_sus_kstat_hlist), GFP_KERNEL);
 	if (!new_entry) {
@@ -747,7 +586,7 @@ void susfs_add_sus_kstat(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_kstat);
 	hash_add(SUS_KSTAT_HLIST, &new_entry->node, info.target_ino);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 	if (update_hlist) {
@@ -786,7 +625,7 @@ void susfs_add_sus_kstat(void __user **user_info) {
 				new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
 	}
 #endif
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_kstat);
 	info.err = 0;
 out_copy_to_user:
 	if (copy_to_user(&((struct st_susfs_sus_kstat __user*)*user_info)->err, &info.err, sizeof(info.err))) {
@@ -810,7 +649,7 @@ void susfs_update_sus_kstat(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_kstat);
 	hash_for_each_safe(SUS_KSTAT_HLIST, bkt, tmp_node, tmp_entry, node) {
 		if (!strcmp(tmp_entry->info.target_pathname, info.target_pathname)) {
 			if (susfs_update_sus_kstat_inode(tmp_entry->info.target_pathname)) {
@@ -845,7 +684,7 @@ void susfs_update_sus_kstat(void __user **user_info) {
 		}
 	}
 out_spin_unlock:
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_kstat);
 out_copy_to_user:
 	if (copy_to_user(&((struct st_susfs_sus_kstat __user*)*user_info)->err, &info.err, sizeof(info.err))) {
 		info.err = -EFAULT;
@@ -890,6 +729,7 @@ void susfs_sus_ino_for_show_map_vma(unsigned long ino, dev_t *out_dev, unsigned
 
 /* try_umount */
 #ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
+static DEFINE_SPINLOCK(susfs_spin_lock_try_umount);
 extern void try_umount(const char *mnt, bool check_mnt, int flags);
 static LIST_HEAD(LH_TRY_UMOUNT_PATH);
 void susfs_add_try_umount(void __user **user_info) {
@@ -920,9 +760,9 @@ void susfs_add_try_umount(void __user **user_info) {
 	memcpy(&new_list->info, &info, sizeof(info));
 
 	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_try_umount);
 	list_add_tail(&new_list->list, &LH_TRY_UMOUNT_PATH);
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_try_umount);
 	SUSFS_LOGI("target_pathname: '%s', umount options: %d, is successfully added to LH_TRY_UMOUNT_PATH\n", new_list->info.target_pathname, new_list->info.mnt_mode);
 	info.err = 0;
 out_copy_to_user:
@@ -991,9 +831,9 @@ add_to_new_list:
 	new_list->info.mnt_mode = MNT_DETACH;
 
 	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_try_umount);
 	list_add_tail(&new_list->list, &LH_TRY_UMOUNT_PATH);
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_try_umount);
 	SUSFS_LOGI("target_pathname: '%s', ino: %lu, umount options: %d, is successfully added to LH_TRY_UMOUNT_PATH\n",
 					new_list->info.target_pathname, path->dentry->d_inode->i_ino, new_list->info.mnt_mode);
 out_free_pathname:
@@ -1004,7 +844,7 @@ out_free_pathname:
 
 /* spoof_uname */
 #ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-static spinlock_t susfs_uname_spin_lock;
+static DEFINE_SPINLOCK(susfs_spin_lock_set_uname);
 static struct st_susfs_uname my_uname;
 static void susfs_my_uname_init(void) {
 	memset(&my_uname, 0, sizeof(my_uname));
@@ -1018,7 +858,7 @@ void susfs_set_uname(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_uname_spin_lock);
+	spin_lock(&susfs_spin_lock_set_uname);
 	if (!strcmp(info.release, "default")) {
 		strncpy(my_uname.release, utsname()->release, __NEW_UTS_LEN);
 	} else {
@@ -1029,7 +869,7 @@ void susfs_set_uname(void __user **user_info) {
 	} else {
 		strncpy(my_uname.version, info.version, __NEW_UTS_LEN);
 	}
-	spin_unlock(&susfs_uname_spin_lock);
+	spin_unlock(&susfs_spin_lock_set_uname);
 	SUSFS_LOGI("setting spoofed release: '%s', version: '%s'\n",
 				my_uname.release, my_uname.version);
 	info.err = 0;
@@ -1041,7 +881,7 @@ out_copy_to_user:
 }
 
 void susfs_spoof_uname(struct new_utsname* tmp) {
-	if (unlikely(my_uname.release[0] == '\0' || spin_is_locked(&susfs_uname_spin_lock)))
+	if (unlikely(my_uname.release[0] == '\0' || spin_is_locked(&susfs_spin_lock_set_uname)))
 		return;
 	strncpy(tmp->release, my_uname.release, __NEW_UTS_LEN);
 	strncpy(tmp->version, my_uname.version, __NEW_UTS_LEN);
@@ -1050,6 +890,8 @@ void susfs_spoof_uname(struct new_utsname* tmp) {
 
 /* enable_log */
 #ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
+static DEFINE_SPINLOCK(susfs_spin_lock_enable_log);
+
 void susfs_enable_log(void __user **user_info) {
 	struct st_susfs_log info = {0};
 
@@ -1058,9 +900,9 @@ void susfs_enable_log(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_enable_log);
 	susfs_is_log_enabled = info.enabled;
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_enable_log);
 	if (susfs_is_log_enabled) {
 		pr_info("susfs: enable logging to kernel");
 	} else {
@@ -1077,6 +919,7 @@ out_copy_to_user:
 
 /* spoof_cmdline_or_bootconfig */
 #ifdef CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG
+static DEFINE_SPINLOCK(susfs_spin_lock_set_cmdline_or_bootconfig);
 static char *fake_cmdline_or_bootconfig = NULL;
 static bool susfs_is_fake_cmdline_or_bootconfig_set = false;
 
@@ -1101,11 +944,11 @@ void susfs_set_cmdline_or_bootconfig(void __user **user_info) {
 		}
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_set_cmdline_or_bootconfig);
 	strncpy(fake_cmdline_or_bootconfig,
 			info->fake_cmdline_or_bootconfig,
 			SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE-1);
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_set_cmdline_or_bootconfig);
 	susfs_is_fake_cmdline_or_bootconfig_set = true;
 	SUSFS_LOGI("fake_cmdline_or_bootconfig is set\n");
 	info->err = 0;
@@ -1133,7 +976,9 @@ int susfs_spoof_cmdline_or_bootconfig(struct seq_file *m) {
 
 /* open_redirect */
 #ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
+static DEFINE_SPINLOCK(susfs_spin_lock_open_redirect);
 static DEFINE_HASHTABLE(OPEN_REDIRECT_HLIST, 10);
+
 static int susfs_update_open_redirect_inode(struct st_susfs_open_redirect_hlist *new_entry) {
 	struct path path_target;
 	struct inode *inode_target;
@@ -1173,7 +1018,7 @@ void susfs_add_open_redirect(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_open_redirect);
 	hash_for_each_safe(OPEN_REDIRECT_HLIST, bkt, tmp_node, tmp_entry, node) {
 		if (!strcmp(tmp_entry->target_pathname, info.target_pathname)) {
 			hash_del(&tmp_entry->node);
@@ -1182,7 +1027,7 @@ void susfs_add_open_redirect(void __user **user_info) {
 			break;
 		}
 	}
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_open_redirect);
 
 	new_entry = kmalloc(sizeof(struct st_susfs_open_redirect_hlist), GFP_KERNEL);
 	if (!new_entry) {
@@ -1200,7 +1045,7 @@ void susfs_add_open_redirect(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_open_redirect);
 	hash_add(OPEN_REDIRECT_HLIST, &new_entry->node, info.target_ino);
 	if (update_hlist) {
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', redirected_pathname: '%s', is successfully updated to OPEN_REDIRECT_HLIST\n",
@@ -1209,7 +1054,7 @@ void susfs_add_open_redirect(void __user **user_info) {
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s' redirected_pathname: '%s', is successfully added to OPEN_REDIRECT_HLIST\n",
 				new_entry->target_ino, new_entry->target_pathname, new_entry->redirected_pathname);
 	}
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_open_redirect);
 	info.err = 0;
 out_copy_to_user:
 	if (copy_to_user(&((struct st_susfs_open_redirect __user*)*user_info)->err, &info.err, sizeof(info.err))) {
@@ -1269,7 +1114,9 @@ out_copy_to_user:
 #endif // #ifdef CONFIG_KSU_SUSFS_SUS_MAP
 
 /* susfs avc log spoofing */
+static DEFINE_SPINLOCK(susfs_spin_lock_set_avc_log_spoofing);
 extern bool susfs_is_avc_log_spoofing_enabled;
+
 void susfs_set_avc_log_spoofing(void __user **user_info) {
 	struct st_susfs_avc_log_spoofing info = {0};
 
@@ -1278,9 +1125,9 @@ void susfs_set_avc_log_spoofing(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_set_avc_log_spoofing);
 	susfs_is_avc_log_spoofing_enabled = info.enabled;
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_set_avc_log_spoofing);
 	SUSFS_LOGI("susfs_is_avc_log_spoofing_enabled: %d\n", info.enabled);
 	info.err = 0;
 out_copy_to_user:
@@ -1330,16 +1177,6 @@ void susfs_get_enabled_features(void __user **user_info) {
 	if (info->err) goto out_copy_to_user;
 	buf_ptr = info->enabled_features + copied_size;
 #endif
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
-	if (info->err) goto out_copy_to_user;
-	buf_ptr = info->enabled_features + copied_size;
-#endif
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
-	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
-	if (info->err) goto out_copy_to_user;
-	buf_ptr = info->enabled_features + copied_size;
-#endif
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
 	info->err = copy_config_to_buf("CONFIG_KSU_SUSFS_SUS_KSTAT\n", buf_ptr, &copied_size, SUSFS_ENABLED_FEATURES_SIZE);
 	if (info->err) goto out_copy_to_user;
@@ -1435,9 +1272,7 @@ out_copy_to_user:
 
 /* susfs_init */
 void susfs_init(void) {
-	spin_lock_init(&susfs_spin_lock);
 #ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-	spin_lock_init(&susfs_uname_spin_lock);
 	susfs_my_uname_init();
 #endif
 	SUSFS_LOGI("susfs is initialized! version: " SUSFS_VERSION " \n");
diff --git a/include/linux/susfs.h b/include/linux/susfs.h
index 74b15cd..095bab7 100644
--- a/include/linux/susfs.h
+++ b/include/linux/susfs.h
@@ -57,13 +57,8 @@ struct st_sdcard_path {
 /* sus_mount */
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 struct st_susfs_sus_mount {
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	unsigned long           target_dev;
-};
-
-struct st_susfs_sus_mount_list {
-	struct list_head                        list;
-	struct st_susfs_sus_mount               info;
+	char                    				target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	int                                     err;
 };
 
 struct st_susfs_hide_sus_mnts_for_all_procs {
@@ -204,7 +199,6 @@ void susfs_add_sus_path_loop(void __user **user_info);
 #endif
 /* sus_mount */
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-void susfs_add_sus_mount(void __user **user_info);
 void susfs_set_hide_sus_mnts_for_all_procs(void __user **user_info);
 void susfs_set_umount_for_zygote_iso_service(void __user **user_info);
 #endif // #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
diff --git a/include/linux/susfs_def.h b/include/linux/susfs_def.h
index a72d360..32029b8 100644
--- a/include/linux/susfs_def.h
+++ b/include/linux/susfs_def.h
@@ -12,7 +12,7 @@
 #define CMD_SUSFS_SET_ANDROID_DATA_ROOT_PATH 0x55551
 #define CMD_SUSFS_SET_SDCARD_ROOT_PATH 0x55552
 #define CMD_SUSFS_ADD_SUS_PATH_LOOP 0x55553
-#define CMD_SUSFS_ADD_SUS_MOUNT 0x55560
+#define CMD_SUSFS_ADD_SUS_MOUNT 0x55560 /* deprecated */
 #define CMD_SUSFS_HIDE_SUS_MNTS_FOR_ALL_PROCS 0x55561
 #define CMD_SUSFS_UMOUNT_FOR_ZYGOTE_ISO_SERVICE 0x55562
 #define CMD_SUSFS_ADD_SUS_KSTAT 0x55570
@@ -46,7 +46,7 @@
 /*
  * inode->i_state => storing flag 'INODE_STATE_'
  * mount->mnt.susfs_mnt_id_backup => storing original mount's mnt_id
- * inode->i_mapping->flags => storing flag 'AS_FLAGS_'
+ * inode->i_mapping->flags => A 'unsigned long' type storing flag 'AS_FLAGS_', bit 1 to 31 is not usable since 6.12
  * nd->state => storing flag 'ND_STATE_'
  * nd->flags => storing flag 'ND_FLAGS_'
  * task_struct->thread_info.flags => storing flag 'TIF_'
@@ -54,20 +54,20 @@
 
 #define TIF_PROC_UMOUNTED 33
 
-#define AS_FLAGS_SUS_PATH 24
-#define AS_FLAGS_SUS_MOUNT 25
-#define AS_FLAGS_SUS_KSTAT 26
-#define AS_FLAGS_OPEN_REDIRECT 27
-#define AS_FLAGS_ANDROID_DATA_ROOT_DIR 28
-#define AS_FLAGS_SDCARD_ROOT_DIR 29
-#define AS_FLAGS_SUS_MAP 30
-#define BIT_SUS_PATH BIT(24)
-#define BIT_SUS_MOUNT BIT(25)
-#define BIT_SUS_KSTAT BIT(26)
-#define BIT_OPEN_REDIRECT BIT(27)
-#define BIT_ANDROID_DATA_ROOT_DIR BIT(28)
-#define BIT_ANDROID_SDCARD_ROOT_DIR BIT(29)
-#define BIT_SUS_MAPS BIT(30)
+#define AS_FLAGS_SUS_PATH 33
+#define AS_FLAGS_SUS_MOUNT 34
+#define AS_FLAGS_SUS_KSTAT 35
+#define AS_FLAGS_OPEN_REDIRECT 36
+#define AS_FLAGS_ANDROID_DATA_ROOT_DIR 37
+#define AS_FLAGS_SDCARD_ROOT_DIR 38
+#define AS_FLAGS_SUS_MAP 39
+#define BIT_SUS_PATH BIT(33)
+#define BIT_SUS_MOUNT BIT(34)
+#define BIT_SUS_KSTAT BIT(35)
+#define BIT_OPEN_REDIRECT BIT(36)
+#define BIT_ANDROID_DATA_ROOT_DIR BIT(37)
+#define BIT_ANDROID_SDCARD_ROOT_DIR BIT(38)
+#define BIT_SUS_MAPS BIT(39)
 
 #define ND_STATE_LOOKUP_LAST 32
 #define ND_STATE_OPEN_LAST 64
diff --git a/security/selinux/avc.c b/security/selinux/avc.c
index 5f60aa7..d2ea9d9 100644
--- a/security/selinux/avc.c
+++ b/security/selinux/avc.c
@@ -166,7 +166,7 @@ static void avc_dump_av(struct audit_buffer *ab, u16 tclass, u32 av)
 }
 #ifdef CONFIG_KSU_SUSFS
 extern u32 susfs_ksu_sid;
-extern u32 susfs_kernel_sid;
+extern u32 susfs_priv_app_sid;
 bool susfs_is_avc_log_spoofing_enabled = false;
 #endif
 
@@ -188,11 +188,11 @@ static void avc_dump_query(struct audit_buffer *ab, struct selinux_state *state,
 
 	rc = security_sid_to_context(state, ssid, &scontext, &scontext_len);
 #ifdef CONFIG_KSU_SUSFS
-	if (unlikely(sad.tsid == susfs_ksu_sid)) {
+	if (unlikely(sad.tsid == susfs_ksu_sid && susfs_is_avc_log_spoofing_enabled)) {
 		if (rc)
-			audit_log_format(ab, " tsid=%d", susfs_kernel_sid && susfs_is_avc_log_spoofing_enabled);
+			audit_log_format(ab, " tsid=%d", susfs_priv_app_sid);
 		else
-			audit_log_format(ab, " tcontext=%s", "u:r:kernel:s0");
+			audit_log_format(ab, " tcontext=%s", "u:r:priv_app:s0:c512,c768");
 		goto bypass_orig_flow;
 	}
 #endif
