diff --git a/fs/namespace.c b/fs/namespace.c
index b5dcd0d..84a1931 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -27,36 +27,39 @@
 #include <linux/bootmem.h>
 #include <linux/task_work.h>
 #include <linux/sched/task.h>
-#if defined(CONFIG_KSU_SUSFS_SUS_MOUNT) || defined(CONFIG_KSU_SUSFS_TRY_UMOUNT)
+#if defined(CONFIG_KSU_SUSFS_SUS_MOUNT) || defined(CONFIG_KSU_SUSFS_TRY_UMOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT)
 #include <linux/susfs_def.h>
 #endif
 
 #include "pnode.h"
 #include "internal.h"
 
-#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+#if defined(CONFIG_KSU_SUSFS_SUS_MOUNT) || defined(CONFIG_KSU_SUSFS_TRY_UMOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT)
 extern bool susfs_is_current_ksu_domain(void);
 extern bool susfs_is_current_zygote_domain(void);
 extern bool susfs_is_boot_completed_triggered;
+#endif // #if defined(CONFIG_KSU_SUSFS_SUS_MOUNT) || defined(CONFIG_KSU_SUSFS_TRY_UMOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT)
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 static DEFINE_IDA(susfs_ksu_mnt_group_ida);
+static atomic64_t susfs_ksu_mounts = ATOMIC64_INIT(0);
 static int susfs_mnt_group_start = DEFAULT_KSU_MNT_GROUP_ID;
 
 #define CL_COPY_MNT_NS BIT(25) /* used by copy_mnt_ns() */
-#endif
+#endif // #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 
 #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
 extern void susfs_auto_add_sus_ksu_default_mount(const char __user *to_pathname);
 bool susfs_is_auto_add_sus_ksu_default_mount_enabled = true;
-#endif
+#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
 #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
 extern void susfs_auto_add_sus_bind_mount(const char *pathname, struct path *path_target);
 bool susfs_is_auto_add_sus_bind_mount_enabled = true;
-#endif
+#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
 #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
 extern void susfs_auto_add_try_umount_for_bind_mount(struct path *path);
 bool susfs_is_auto_add_try_umount_for_bind_mount_enabled = true;
-#endif
+#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
 
 /* Maximum number of mounts in a mount namespace */
 unsigned int sysctl_mount_max __read_mostly = 100000;
@@ -2617,7 +2620,9 @@ static int do_loopback(struct path *path, const char *old_name,
 		unlock_mount_hash();
 	}
 #if defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT) || defined(CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT)
-	if (susfs_is_current_ksu_domain()) {
+	// - Check if bind mounted path should be hidden and umounted automatically.
+	// - We keep checking for ksu process only until boot-completed stage is triggered
+	if (!susfs_is_boot_completed_triggered && susfs_is_current_ksu_domain()) {
 #if defined(CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT)
 		if (susfs_is_auto_add_sus_bind_mount_enabled) {
 			susfs_auto_add_sus_bind_mount(old_name, &old_path);
@@ -3928,6 +3933,11 @@ void susfs_reorder_mnt_id(void) {
 		return;
 	}
 
+	// Do not reorder the mnt_id if there is no any ksu mount at all
+	if (atomic64_read(&susfs_ksu_mounts) == 0) {
+		return;
+	}
+
 	get_mnt_ns(mnt_ns);
 	first_mnt_id = list_first_entry(&mnt_ns->list, struct mount, mnt_list)->mnt_id;
 	list_for_each_entry(mnt, &mnt_ns->list, mnt_list) {
@@ -3940,17 +3950,16 @@ void susfs_reorder_mnt_id(void) {
 	}
 	put_mnt_ns(mnt_ns);
 }
-#endif
-#ifdef CONFIG_KSU_SUSFS
-bool susfs_is_mnt_devname_ksu(struct path *path) {
-	struct mount *mnt;
 
-	if (path && path->mnt) {
-		mnt = real_mount(path->mnt);
-		if (mnt && mnt->mnt_devname && !strcmp(mnt->mnt_devname, "KSU")) {
-			return true;
-		}
-	}
-	return false;
+void susfs_assign_fake_mnt_id(struct mount *mnt) {
+	lock_mount_hash();
+
+	ida_remove(&mnt_id_ida, mnt->mnt_id);
+
+	mnt->mnt_id = DEFAULT_KSU_MNT_ID;
+	mnt->mnt_group_id = ida_pre_get(&susfs_ksu_mnt_group_ida, GFP_KERNEL);
+	atomic64_add(1, &susfs_ksu_mounts);
+
+	unlock_mount_hash();
 }
 #endif
diff --git a/fs/susfs.c b/fs/susfs.c
index 543144c..767026f 100644
--- a/fs/susfs.c
+++ b/fs/susfs.c
@@ -17,8 +17,6 @@
 #include <linux/susfs.h>
 #include "mount.h"
 
-static spinlock_t susfs_spin_lock;
-
 extern bool susfs_is_current_ksu_domain(void);
 
 #ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
@@ -40,6 +38,7 @@ bool susfs_starts_with(const char *str, const char *prefix) {
 
 /* sus_path */
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
+static DEFINE_SPINLOCK(susfs_spin_lock_sus_path);
 static LIST_HEAD(LH_SUS_PATH_LOOP);
 static LIST_HEAD(LH_SUS_PATH_ANDROID_DATA);
 static LIST_HEAD(LH_SUS_PATH_SDCARD);
@@ -166,7 +165,7 @@ void susfs_add_sus_path(void __user **user_info) {
 		}
 		list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_ANDROID_DATA, list) {
 			if (unlikely(!strcmp(cursor->info.target_pathname, path.dentry->d_name.name))) {
-				spin_lock(&susfs_spin_lock);
+				spin_lock(&susfs_spin_lock_sus_path);
 				cursor->info.target_ino = info.target_ino;
 				strncpy(cursor->info.target_pathname, path.dentry->d_name.name, SUSFS_MAX_LEN_PATHNAME - 1);
 				strncpy(cursor->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
@@ -174,7 +173,7 @@ void susfs_add_sus_path(void __user **user_info) {
 				cursor->path_len = strlen(cursor->info.target_pathname);
 				SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully updated to LH_SUS_PATH_ANDROID_DATA\n",
 							cursor->info.target_ino, cursor->target_pathname, cursor->info.i_uid);
-				spin_unlock(&susfs_spin_lock);
+				spin_unlock(&susfs_spin_lock_sus_path);
 				info.err = 0;
 				goto out_kfree_tmp_buf;
 			}
@@ -190,11 +189,11 @@ void susfs_add_sus_path(void __user **user_info) {
 		new_list->info.i_uid = info.i_uid;
 		new_list->path_len = strlen(new_list->info.target_pathname);
 		INIT_LIST_HEAD(&new_list->list);
-		spin_lock(&susfs_spin_lock);
+		spin_lock(&susfs_spin_lock_sus_path);
 		list_add_tail(&new_list->list, &LH_SUS_PATH_ANDROID_DATA);
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_ANDROID_DATA\n",
 					new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
-		spin_unlock(&susfs_spin_lock);
+		spin_unlock(&susfs_spin_lock_sus_path);
 		info.err = 0;
 		goto out_kfree_tmp_buf;
 	} else if (strstr(resolved_pathname, sdcard_path.target_pathname)) {
@@ -205,7 +204,7 @@ void susfs_add_sus_path(void __user **user_info) {
 		}
 		list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_SDCARD, list) {
 			if (unlikely(!strcmp(cursor->info.target_pathname, path.dentry->d_name.name))) {
-				spin_lock(&susfs_spin_lock);
+				spin_lock(&susfs_spin_lock_sus_path);
 				cursor->info.target_ino = info.target_ino;
 				strncpy(cursor->info.target_pathname, path.dentry->d_name.name, SUSFS_MAX_LEN_PATHNAME - 1);
 				strncpy(cursor->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
@@ -213,7 +212,7 @@ void susfs_add_sus_path(void __user **user_info) {
 				cursor->path_len = strlen(cursor->info.target_pathname);
 				SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully updated to LH_SUS_PATH_SDCARD\n",
 							cursor->info.target_ino, cursor->target_pathname, cursor->info.i_uid);
-				spin_unlock(&susfs_spin_lock);
+				spin_unlock(&susfs_spin_lock_sus_path);
 				info.err = 0;
 				goto out_kfree_tmp_buf;
 			}
@@ -229,11 +228,11 @@ void susfs_add_sus_path(void __user **user_info) {
 		new_list->info.i_uid = info.i_uid;
 		new_list->path_len = strlen(new_list->info.target_pathname);
 		INIT_LIST_HEAD(&new_list->list);
-		spin_lock(&susfs_spin_lock);
+		spin_lock(&susfs_spin_lock_sus_path);
 		list_add_tail(&new_list->list, &LH_SUS_PATH_SDCARD);
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_SDCARD\n",
 					new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
-		spin_unlock(&susfs_spin_lock);
+		spin_unlock(&susfs_spin_lock_sus_path);
 		info.err = 0;
 		goto out_kfree_tmp_buf;
 	}
@@ -300,7 +299,7 @@ void susfs_add_sus_path_loop(void __user **user_info) {
 
 	list_for_each_entry_safe(cursor, temp, &LH_SUS_PATH_LOOP, list) {
 		if (unlikely(!strcmp(cursor->info.target_pathname, resolved_pathname))) {
-			spin_lock(&susfs_spin_lock);
+			spin_lock(&susfs_spin_lock_sus_path);
 			cursor->info.target_ino = info.target_ino;
 			strncpy(cursor->info.target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
 			strncpy(cursor->target_pathname, resolved_pathname, SUSFS_MAX_LEN_PATHNAME - 1);
@@ -308,7 +307,7 @@ void susfs_add_sus_path_loop(void __user **user_info) {
 			cursor->path_len = strlen(cursor->info.target_pathname);
 			SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully updated to LH_SUS_PATH_LOOP\n",
 						cursor->info.target_ino, cursor->target_pathname, cursor->info.i_uid);
-			spin_unlock(&susfs_spin_lock);
+			spin_unlock(&susfs_spin_lock_sus_path);
 			goto out_set_sus_path;
 		}
 	}
@@ -323,11 +322,11 @@ void susfs_add_sus_path_loop(void __user **user_info) {
 	new_list->info.i_uid = info.i_uid;
 	new_list->path_len = strlen(new_list->info.target_pathname);
 	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_path);
 	list_add_tail(&new_list->list, &LH_SUS_PATH_LOOP);
 	SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', i_uid: '%u', is successfully added to LH_SUS_PATH_LOOP\n",
 				new_list->info.target_ino, new_list->target_pathname, new_list->info.i_uid);
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_path);
 out_set_sus_path:
 	spin_lock(&inode->i_lock);
 	set_bit(AS_FLAGS_SUS_PATH, &inode->i_mapping->flags);
@@ -460,95 +459,58 @@ bool susfs_is_inode_sus_path(struct inode *inode) {
 
 /* sus_mount */
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+static DEFINE_SPINLOCK(susfs_spin_lock_sus_mount);
 bool susfs_hide_sus_mnts_for_all_procs = true; // hide sus mounts for all processes by default
-static LIST_HEAD(LH_SUS_MOUNT);
-static void susfs_update_sus_mount_inode(char *target_pathname) {
+extern void susfs_assign_fake_mnt_id(struct mount *mnt);
+
+void susfs_add_sus_mount(void __user **user_info) {
+	struct st_susfs_sus_mount info = {0};
 	struct mount *mnt = NULL;
 	struct path p;
 	struct inode *inode = NULL;
-	int err = 0;
+	if (copy_from_user(&info, (struct st_susfs_sus_mount __user*)*user_info, sizeof(info))) {
+		info.err = -EFAULT;
+		goto out_copy_to_user;
+	}
 
-	err = kern_path(target_pathname, 0, &p);
-	if (err) {
-		SUSFS_LOGE("Failed opening file '%s'\n", target_pathname);
-		return;
+	info.err = kern_path(info.target_pathname, LOOKUP_FOLLOW, &p);
+	if (info.err) {
+		SUSFS_LOGE("Failed opening file '%s'\n", info.target_pathname);
+		goto out_copy_to_user;
 	}
 
-	/* It is important to check if the mount has a legit peer group id, if so we cannot add them to sus_mount,
-	 * since there are chances that the mount is a legit mountpoint, and it can be misued by other susfs functions in future.
-	 * And by doing this it won't affect the sus_mount check as other susfs functions check by mnt->mnt_id
-	 * instead of BIT_SUS_MOUNT.
-	 */
 	mnt = real_mount(p.mnt);
-	if (mnt->mnt_group_id > 0 && // 0 means no peer group
-		mnt->mnt_group_id < DEFAULT_KSU_MNT_GROUP_ID) {
-		SUSFS_LOGE("skip setting SUS_MOUNT inode state for path '%s' since its source mount has a legit peer group id\n", target_pathname);
-		return;
+	if (!(mnt->mnt.mnt_flags & MNT_SHARED)) {
+		SUSFS_LOGE("mnt '%s' is not shared\n", info.target_pathname);
+		info.err = -EINVAL;
+		goto out_path_put_path;
 	}
 
+	if (mnt->mnt_id >= DEFAULT_KSU_MNT_ID) {
+		SUSFS_LOGE("mnt '%s' has been assigned a fake mnt_id already\n", info.target_pathname);
+		info.err = -EINVAL;
+		goto out_path_put_path;
+ 	}
+
+	SUSFS_LOGI("Assigning fake mnt_id and mnt_group_id for mnt '%s'\n", info.target_pathname);
+	susfs_assign_fake_mnt_id(mnt);
+
 	inode = d_inode(p.dentry);
 	if (!inode) {
-		path_put(&p);
 		SUSFS_LOGE("inode is NULL\n");
-		return;
+		info.err = -EINVAL;
+		goto out_path_put_path;
 	}
 
 	if (!(inode->i_mapping->flags & BIT_SUS_MOUNT)) {
+		SUSFS_LOGI("mnt '%s', is flagged as BIT_SUS_MOUNT\n", info.target_pathname);
 		spin_lock(&inode->i_lock);
 		set_bit(AS_FLAGS_SUS_MOUNT, &inode->i_mapping->flags);
 		spin_unlock(&inode->i_lock);
 	}
-	path_put(&p);
-}
-
-void susfs_add_sus_mount(void __user **user_info) {
-	struct st_susfs_sus_mount info = {0};
-	struct st_susfs_sus_mount_list *cursor = NULL, *temp = NULL;
-	struct st_susfs_sus_mount_list *new_list = NULL;
-
-	if (copy_from_user(&info, (struct st_susfs_sus_mount __user*)*user_info, sizeof(info))) {
-		info.err = -EFAULT;
-		goto out_copy_to_user;
-	}
-
-#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)
-#ifdef CONFIG_MIPS
-	info.target_dev = new_decode_dev(info.target_dev);
-#else
-	info.target_dev = huge_decode_dev(info.target_dev);
-#endif /* CONFIG_MIPS */
-#else
-	info.target_dev = old_decode_dev(info.target_dev);
-#endif /* defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64) */
-
-	list_for_each_entry_safe(cursor, temp, &LH_SUS_MOUNT, list) {
-		if (unlikely(!strcmp(cursor->info.target_pathname, info.target_pathname))) {
-			spin_lock(&susfs_spin_lock);
-			memcpy(&cursor->info, &info, sizeof(info));
-			susfs_update_sus_mount_inode(cursor->info.target_pathname);
-			SUSFS_LOGI("target_pathname: '%s', target_dev: '%lu', is successfully updated to LH_SUS_MOUNT\n",
-						cursor->info.target_pathname, cursor->info.target_dev);
-			spin_unlock(&susfs_spin_lock);
-			goto out_copy_to_user;
-		}
-	}
-
-	new_list = kmalloc(sizeof(struct st_susfs_sus_mount_list), GFP_KERNEL);
-	if (!new_list) {
-		info.err = -ENOMEM;
-		goto out_copy_to_user;
-	}
-
-	memcpy(&new_list->info, &info, sizeof(info));
-	susfs_update_sus_mount_inode(new_list->info.target_pathname);
-
-	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
-	list_add_tail(&new_list->list, &LH_SUS_MOUNT);
-	SUSFS_LOGI("target_pathname: '%s', target_dev: '%lu', is successfully added to LH_SUS_MOUNT\n",
-				new_list->info.target_pathname, new_list->info.target_dev);
-	spin_unlock(&susfs_spin_lock);
 	info.err = 0;
+out_path_put_path:
+	path_put(&p);
 out_copy_to_user:
 	if (copy_to_user(&((struct st_susfs_sus_mount __user*)*user_info)->err, &info.err, sizeof(info.err))) {
 		info.err = -EINVAL;
@@ -631,9 +593,9 @@ void susfs_set_hide_sus_mnts_for_all_procs(void __user **user_info) {
 		info.err = -EFAULT;
 		goto out_copy_to_user;
 	}
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_mount);
 	susfs_hide_sus_mnts_for_all_procs = info.enabled;
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_mount);
 	SUSFS_LOGI("susfs_hide_sus_mnts_for_all_procs: %d\n", info.enabled);
 	info.err = 0;
 out_copy_to_user:
@@ -651,9 +613,9 @@ void susfs_set_umount_for_zygote_iso_service(void __user **user_info) {
 		info.err = -EFAULT;
 		goto out_copy_to_user;
 	}
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_mount);
 	susfs_is_umount_for_zygote_iso_service_enabled = info.enabled;
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_mount);
 	SUSFS_LOGI("susfs_is_umount_for_zygote_iso_service_enabled: %d\n", info.enabled);
 	info.err = 0;
 out_copy_to_user:
@@ -666,6 +628,7 @@ out_copy_to_user:
 
 /* sus_kstat */
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+static DEFINE_SPINLOCK(susfs_spin_lock_sus_kstat);
 static DEFINE_HASHTABLE(SUS_KSTAT_HLIST, 10);
 static int susfs_update_sus_kstat_inode(char *target_pathname) {
 	struct path p;
@@ -711,7 +674,7 @@ void susfs_add_sus_kstat(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_kstat);
 	hash_for_each_safe(SUS_KSTAT_HLIST, bkt, tmp_node, tmp_entry, node) {
 		if (!strcmp(tmp_entry->info.target_pathname, info.target_pathname)) {
 			hash_del(&tmp_entry->node);
@@ -720,7 +683,7 @@ void susfs_add_sus_kstat(void __user **user_info) {
 			break;
 		}
 	}
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_kstat);
 
 	new_entry = kmalloc(sizeof(struct st_susfs_sus_kstat_hlist), GFP_KERNEL);
 	if (!new_entry) {
@@ -747,7 +710,7 @@ void susfs_add_sus_kstat(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_kstat);
 	hash_add(SUS_KSTAT_HLIST, &new_entry->node, info.target_ino);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 	if (update_hlist) {
@@ -786,7 +749,7 @@ void susfs_add_sus_kstat(void __user **user_info) {
 				new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
 	}
 #endif
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_kstat);
 	info.err = 0;
 out_copy_to_user:
 	if (copy_to_user(&((struct st_susfs_sus_kstat __user*)*user_info)->err, &info.err, sizeof(info.err))) {
@@ -810,7 +773,7 @@ void susfs_update_sus_kstat(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_sus_kstat);
 	hash_for_each_safe(SUS_KSTAT_HLIST, bkt, tmp_node, tmp_entry, node) {
 		if (!strcmp(tmp_entry->info.target_pathname, info.target_pathname)) {
 			if (susfs_update_sus_kstat_inode(tmp_entry->info.target_pathname)) {
@@ -845,7 +808,7 @@ void susfs_update_sus_kstat(void __user **user_info) {
 		}
 	}
 out_spin_unlock:
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_sus_kstat);
 out_copy_to_user:
 	if (copy_to_user(&((struct st_susfs_sus_kstat __user*)*user_info)->err, &info.err, sizeof(info.err))) {
 		info.err = -EFAULT;
@@ -890,7 +853,8 @@ void susfs_sus_ino_for_show_map_vma(unsigned long ino, dev_t *out_dev, unsigned
 
 /* try_umount */
 #ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-extern void try_umount(const char *mnt, bool check_mnt, int flags);
+static DEFINE_SPINLOCK(susfs_spin_lock_try_umount);
+extern void try_umount(const char *mnt, int flags);
 static LIST_HEAD(LH_TRY_UMOUNT_PATH);
 void susfs_add_try_umount(void __user **user_info) {
 	struct st_susfs_try_umount info = {0};
@@ -920,9 +884,9 @@ void susfs_add_try_umount(void __user **user_info) {
 	memcpy(&new_list->info, &info, sizeof(info));
 
 	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_try_umount);
 	list_add_tail(&new_list->list, &LH_TRY_UMOUNT_PATH);
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_try_umount);
 	SUSFS_LOGI("target_pathname: '%s', umount options: %d, is successfully added to LH_TRY_UMOUNT_PATH\n", new_list->info.target_pathname, new_list->info.mnt_mode);
 	info.err = 0;
 out_copy_to_user:
@@ -937,7 +901,7 @@ void susfs_try_umount(void) {
 
 	// We should umount in reversed order
 	list_for_each_entry_reverse(cursor, &LH_TRY_UMOUNT_PATH, list) {
-		try_umount(cursor->info.target_pathname, false, cursor->info.mnt_mode);
+		try_umount(cursor->info.target_pathname, cursor->info.mnt_mode);
 	}
 }
 
@@ -991,9 +955,9 @@ add_to_new_list:
 	new_list->info.mnt_mode = MNT_DETACH;
 
 	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_try_umount);
 	list_add_tail(&new_list->list, &LH_TRY_UMOUNT_PATH);
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_try_umount);
 	SUSFS_LOGI("target_pathname: '%s', ino: %lu, umount options: %d, is successfully added to LH_TRY_UMOUNT_PATH\n",
 					new_list->info.target_pathname, path->dentry->d_inode->i_ino, new_list->info.mnt_mode);
 out_free_pathname:
@@ -1004,7 +968,7 @@ out_free_pathname:
 
 /* spoof_uname */
 #ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-static spinlock_t susfs_uname_spin_lock;
+static DEFINE_SPINLOCK(susfs_spin_lock_set_uname);
 static struct st_susfs_uname my_uname;
 static void susfs_my_uname_init(void) {
 	memset(&my_uname, 0, sizeof(my_uname));
@@ -1018,7 +982,7 @@ void susfs_set_uname(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_uname_spin_lock);
+	spin_lock(&susfs_spin_lock_set_uname);
 	if (!strcmp(info.release, "default")) {
 		strncpy(my_uname.release, utsname()->release, __NEW_UTS_LEN);
 	} else {
@@ -1029,7 +993,7 @@ void susfs_set_uname(void __user **user_info) {
 	} else {
 		strncpy(my_uname.version, info.version, __NEW_UTS_LEN);
 	}
-	spin_unlock(&susfs_uname_spin_lock);
+	spin_unlock(&susfs_spin_lock_set_uname);
 	SUSFS_LOGI("setting spoofed release: '%s', version: '%s'\n",
 				my_uname.release, my_uname.version);
 	info.err = 0;
@@ -1041,7 +1005,7 @@ out_copy_to_user:
 }
 
 void susfs_spoof_uname(struct new_utsname* tmp) {
-	if (unlikely(my_uname.release[0] == '\0' || spin_is_locked(&susfs_uname_spin_lock)))
+	if (unlikely(my_uname.release[0] == '\0' || spin_is_locked(&susfs_spin_lock_set_uname)))
 		return;
 	strncpy(tmp->release, my_uname.release, __NEW_UTS_LEN);
 	strncpy(tmp->version, my_uname.version, __NEW_UTS_LEN);
@@ -1050,6 +1014,8 @@ void susfs_spoof_uname(struct new_utsname* tmp) {
 
 /* enable_log */
 #ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
+static DEFINE_SPINLOCK(susfs_spin_lock_enable_log);
+
 void susfs_enable_log(void __user **user_info) {
 	struct st_susfs_log info = {0};
 
@@ -1058,9 +1024,9 @@ void susfs_enable_log(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_enable_log);
 	susfs_is_log_enabled = info.enabled;
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_enable_log);
 	if (susfs_is_log_enabled) {
 		pr_info("susfs: enable logging to kernel");
 	} else {
@@ -1077,6 +1043,7 @@ out_copy_to_user:
 
 /* spoof_cmdline_or_bootconfig */
 #ifdef CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG
+static DEFINE_SPINLOCK(susfs_spin_lock_set_cmdline_or_bootconfig);
 static char *fake_cmdline_or_bootconfig = NULL;
 static bool susfs_is_fake_cmdline_or_bootconfig_set = false;
 
@@ -1101,11 +1068,11 @@ void susfs_set_cmdline_or_bootconfig(void __user **user_info) {
 		}
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_set_cmdline_or_bootconfig);
 	strncpy(fake_cmdline_or_bootconfig,
 			info->fake_cmdline_or_bootconfig,
 			SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE-1);
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_set_cmdline_or_bootconfig);
 	susfs_is_fake_cmdline_or_bootconfig_set = true;
 	SUSFS_LOGI("fake_cmdline_or_bootconfig is set\n");
 	info->err = 0;
@@ -1133,7 +1100,9 @@ int susfs_spoof_cmdline_or_bootconfig(struct seq_file *m) {
 
 /* open_redirect */
 #ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
+static DEFINE_SPINLOCK(susfs_spin_lock_open_redirect);
 static DEFINE_HASHTABLE(OPEN_REDIRECT_HLIST, 10);
+
 static int susfs_update_open_redirect_inode(struct st_susfs_open_redirect_hlist *new_entry) {
 	struct path path_target;
 	struct inode *inode_target;
@@ -1173,7 +1142,7 @@ void susfs_add_open_redirect(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_open_redirect);
 	hash_for_each_safe(OPEN_REDIRECT_HLIST, bkt, tmp_node, tmp_entry, node) {
 		if (!strcmp(tmp_entry->target_pathname, info.target_pathname)) {
 			hash_del(&tmp_entry->node);
@@ -1182,7 +1151,7 @@ void susfs_add_open_redirect(void __user **user_info) {
 			break;
 		}
 	}
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_open_redirect);
 
 	new_entry = kmalloc(sizeof(struct st_susfs_open_redirect_hlist), GFP_KERNEL);
 	if (!new_entry) {
@@ -1200,7 +1169,7 @@ void susfs_add_open_redirect(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_open_redirect);
 	hash_add(OPEN_REDIRECT_HLIST, &new_entry->node, info.target_ino);
 	if (update_hlist) {
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', redirected_pathname: '%s', is successfully updated to OPEN_REDIRECT_HLIST\n",
@@ -1209,7 +1178,7 @@ void susfs_add_open_redirect(void __user **user_info) {
 		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s' redirected_pathname: '%s', is successfully added to OPEN_REDIRECT_HLIST\n",
 				new_entry->target_ino, new_entry->target_pathname, new_entry->redirected_pathname);
 	}
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_open_redirect);
 	info.err = 0;
 out_copy_to_user:
 	if (copy_to_user(&((struct st_susfs_open_redirect __user*)*user_info)->err, &info.err, sizeof(info.err))) {
@@ -1269,7 +1238,9 @@ out_copy_to_user:
 #endif // #ifdef CONFIG_KSU_SUSFS_SUS_MAP
 
 /* susfs avc log spoofing */
+static DEFINE_SPINLOCK(susfs_spin_lock_set_avc_log_spoofing);
 extern bool susfs_is_avc_log_spoofing_enabled;
+
 void susfs_set_avc_log_spoofing(void __user **user_info) {
 	struct st_susfs_avc_log_spoofing info = {0};
 
@@ -1278,9 +1249,9 @@ void susfs_set_avc_log_spoofing(void __user **user_info) {
 		goto out_copy_to_user;
 	}
 
-	spin_lock(&susfs_spin_lock);
+	spin_lock(&susfs_spin_lock_set_avc_log_spoofing);
 	susfs_is_avc_log_spoofing_enabled = info.enabled;
-	spin_unlock(&susfs_spin_lock);
+	spin_unlock(&susfs_spin_lock_set_avc_log_spoofing);
 	SUSFS_LOGI("susfs_is_avc_log_spoofing_enabled: %d\n", info.enabled);
 	info.err = 0;
 out_copy_to_user:
@@ -1435,9 +1406,7 @@ out_copy_to_user:
 
 /* susfs_init */
 void susfs_init(void) {
-	spin_lock_init(&susfs_spin_lock);
 #ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-	spin_lock_init(&susfs_uname_spin_lock);
 	susfs_my_uname_init();
 #endif
 	SUSFS_LOGI("susfs is initialized! version: " SUSFS_VERSION " \n");
diff --git a/include/linux/susfs.h b/include/linux/susfs.h
index 74b15cd..c123606 100644
--- a/include/linux/susfs.h
+++ b/include/linux/susfs.h
@@ -57,13 +57,8 @@ struct st_sdcard_path {
 /* sus_mount */
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 struct st_susfs_sus_mount {
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	unsigned long           target_dev;
-};
-
-struct st_susfs_sus_mount_list {
-	struct list_head                        list;
-	struct st_susfs_sus_mount               info;
+	char                    				target_pathname[SUSFS_MAX_LEN_PATHNAME];
+	int                                     err;
 };
 
 struct st_susfs_hide_sus_mnts_for_all_procs {
diff --git a/security/selinux/avc.c b/security/selinux/avc.c
index 5f60aa7..d2ea9d9 100644
--- a/security/selinux/avc.c
+++ b/security/selinux/avc.c
@@ -166,7 +166,7 @@ static void avc_dump_av(struct audit_buffer *ab, u16 tclass, u32 av)
 }
 #ifdef CONFIG_KSU_SUSFS
 extern u32 susfs_ksu_sid;
-extern u32 susfs_kernel_sid;
+extern u32 susfs_priv_app_sid;
 bool susfs_is_avc_log_spoofing_enabled = false;
 #endif
 
@@ -188,11 +188,11 @@ static void avc_dump_query(struct audit_buffer *ab, struct selinux_state *state,
 
 	rc = security_sid_to_context(state, ssid, &scontext, &scontext_len);
 #ifdef CONFIG_KSU_SUSFS
-	if (unlikely(sad.tsid == susfs_ksu_sid)) {
+	if (unlikely(sad.tsid == susfs_ksu_sid && susfs_is_avc_log_spoofing_enabled)) {
 		if (rc)
-			audit_log_format(ab, " tsid=%d", susfs_kernel_sid && susfs_is_avc_log_spoofing_enabled);
+			audit_log_format(ab, " tsid=%d", susfs_priv_app_sid);
 		else
-			audit_log_format(ab, " tcontext=%s", "u:r:kernel:s0");
+			audit_log_format(ab, " tcontext=%s", "u:r:priv_app:s0:c512,c768");
 		goto bypass_orig_flow;
 	}
 #endif
