name: 'Patch Kernel for no-kprobe.'

runs:
  using: 'composite'
  steps:
      - name: Patch Kernel for no-kprobe
        shell: bash
        run: |
          cd $GITHUB_WORKSPACE/device_kernel

          # Function
          PACK_FILES(){
            temp_dir=$(mktemp -d)
            find . -name "*.rej" -exec cp --parents {} "$temp_dir" \;
            find . -name "*.rej" | sed 's/\.rej$//' | xargs -I {} test -f {} && find . -name "*.rej" | sed 's/\.rej$//' | xargs -I {} cp --parents {} "$temp_dir"
            tar -czf "rej_files_kernel_write_read.tar.gz" -C "$temp_dir" .
            rm -rf "$temp_dir"
            echo "[+] Packed Successfully."

            find . -type f \( -name "*.rej" -o -name "*.orig" \) -delete
            echo "[+] Removed all .rej and .orig files."
            echo "[+] =================================== "
          }
          REJ_FOUND(){
            if [[ "${{ env.BUILD_DEBUGGER }}" == "true" ]]; then
                echo "[+] Checking Kernel write and read patch rej files..."
                mapfile -t REJ_FILES < <(find . -type f -name "*.rej")
                if [ ${#REJ_FILES[@]} -eq 0 ]; then
                    echo "[+] Your kernel have no any rej files, Skipped."
                else
                    for CAT_REJ in "${REJ_FILES[@]}"; do
                        echo "[-] Found .rej file: $CAT_REJ"
                        cat $CAT_REJ
                        echo "[+] =================================== "
                    done
                fi

                if [[ "${{ env.SKIP_PATCH }}" == "true" ]]; then
                    echo "[+] SKIP_PATCH enabled, Skipped. "
                    PACK_FILES
                elif [[ "${{ env.SKIP_PATCH }}" != "true" ]]; then
                    echo "[-] Found .rej files, Stopped! "
                    PACK_FILES
                    false
                fi
            fi
          }

          # Check hook
          if grep -q "CONFIG_KSU" "fs/exec.c"; then
            echo "Your kernel source code appears to have been manually patched, so this step is skipped."

          # Check normal hook
          elif [[ ${{ env.HOOK_METHOD }} == "normal" ]]; then
            if [[ ${{ env.FIRST_VERSION }} -le 3 ]] && [[ ${{ env.SECOND_VERSION }} -le 10 ]]; then
                echo "normal hook cannot supported for kernel ${{ env.KERNEL_VERSION }}."
                false
            fi
            cp /tmp/Patches/normal_hook_patches.sh ./
            cp /tmp/Patches/backport_patches_early.sh ./

            bash normal_hook_patches.sh ./
            bash backport_patches_early.sh

            echo "execuated normal hook and backport patch successfully."

          # Check syscall hook
          elif [[ ${{ env.HOOK_METHOD }} == "syscall" ]]; then
            if [[ "${{ env.HOOK_OLDER }}" == "true" ]]; then
                cp /tmp/Patches/syscall_hook_patches_older.sh ./
                bash syscall_hook_patches_older.sh ./

                echo "execuated syscall hook older successfully."
            else
                cp /tmp/Patches/syscall_hook_patches.sh ./
                bash syscall_hook_patches.sh ./

                echo "execuated syscall hook successfully."
            fi

            if [[ ${{ env.FIRST_VERSION }} -le 3 ]] && [[ ${{ env.SECOND_VERSION }} -le 10 ]]; then
                cp /tmp/Patches/backport_patches_early.sh ./
                bash backport_patches_early.sh

                echo "kernel ${{ env.KERNEL_VERSION }} cannot supported patch kernel_write and kernel_read,so only execuated backport patch older."
            elif [[ ${{ env.FIRST_VERSION }} -le 4 ]] && [[ ${{ env.SECOND_VERSION }} -le 9 ]]; then
                cp /tmp/Patches/backport_patches.sh ./
                cp /tmp/Patches/Patch/backport_kernel_read_and_kernel_write_to_ksu.patch ./

                bash backport_patches.sh
                if grep -q "kernel_read" "fs/read_write.c"; then
                    echo ">>>>>>>>>>>>>>>Backport Patch<<<<<<<<<<<<<<<<"
                    echo ">                                           <"
                    echo "Your kernel patched the kernel patch, Skipped"
                    echo ">                                           <"
                    echo ">>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<"
                else
                    patch -p1 < backport_kernel_read_and_kernel_write_to_ksu.patch || true
                    REJ_FOUND
                fi

                echo "execuated backport patch (contain kernel_read and kernel_write patch) successfully."
            else
                cp /tmp/Patches/backport_patches.sh ./
                bash backport_patches.sh

                echo "execuated backport patch successfully."
            fi

          # Check tracepoint hook
          elif [[ ${{ env.HOOK_METHOD }} == "tracepoint" ]]; then
            if [[ "${{ env.KERNELSU_AUTO_GET }}" == "true" ]] && [[ "${{ env.KERNELSU_AUTO_FORK }}" != "sukisu" ]]; then
                echo "======================================Error======================================"
                echo "= your kernelsu branch could not supported tracepoint, use SukiSU-Ultra please. ="
                echo "================================================================================="
                false
            elif [[ "${{ env.KERNELSU_AUTO_GET }}" != "true" ]] && [[ "${{ env.KERNELSU_SOURCE }}" != *SukiSU* ]]; then
                echo "======================================Error======================================"
                echo "= your kernelsu branch could not supported tracepoint, use SukiSU-Ultra please. ="
                echo "================================================================================="
                false
            fi
            cp /tmp/Patches/tracepoint_hook_patches.sh ./
            bash tracepoint_hook_patches.sh ./

            echo "execuated tracepoint hook successfully."

            if [[ ${{ env.FIRST_VERSION }} -le 3 ]] && [[ ${{ env.SECOND_VERSION }} -le 10 ]]; then
                cp /tmp/Patches/backport_patches_early.sh ./
                bash backport_patches_early.sh

                echo "kernel ${{ env.KERNEL_VERSION }} cannot supported patch kernel_write and kernel_read,so only execuated backport patch older."
            elif [[ ${{ env.FIRST_VERSION }} -le 4 ]] && [[ ${{ env.SECOND_VERSION }} -le 9 ]]; then
                cp /tmp/Patches/backport_patches.sh ./
                cp /tmp/Patches/Patch/backport_kernel_read_and_kernel_write_to_ksu.patch ./

                bash backport_patches.sh
                patch -p1 < backport_kernel_read_and_kernel_write_to_ksu.patch || true

                echo "execuated backport patch (contain kernel_read and kernel_write patch) successfully."
            else
                cp /tmp/Patches/backport_patches.sh ./
                bash backport_patches.sh

                echo "execuated backport patch successfully."
            fi

          else
            echo "please input vaild option!"
            false

          fi

      - name: Upload Build Kernel Patch Rejected Files
        if: env.BUILD_DEBUGGER == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: patch_kernel_write_read_rejected_files
          path: |
            device_kernel/rej_files_kernel_write_read.tar.gz
